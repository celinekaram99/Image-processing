# -*- coding: utf-8 -*-
"""ImageProcessingEx_03_BinaryImages.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1Ck54_fITMtTk_njC4LsNAbTUiWDHozFK

# Image Processing Assignment 3: Binary images

Before we start, please put your names and IDs in following format

: Firstname LASTNAME, #00000000   //   (e.g.) Dana LEVI, #12345678

**Your Answer:**   
celine karam, #314658428
marah habashy, #211668751

In this exercise, you will implement **Binary Images** algorithms.

Methods: as explained in class.

Notes:
*   Write your code in the dedicated areas (TODO blocks). You can add helper functions.
*   Submission email should include a link to the Colab submission notebook located on your Google Drive with Commenter access right to nev1958a@gmail.com
*   The solution notebook should be able to be run (‘Run all’) with no errors.
In case of errors, the submission will be disqualified.
*   The grade will depend on correct performance on several grayscale images and on clean programming and documentation.
*   Do not forget to add the Names and Student I.D. at the top of the notebook.
*   All images are given as 2-dimensional matrices of type `float`, with values in the range [0..1].
*   Pay Attention! In the following functions, the returned images must be the same size as the original Images!

Please implement the following functions:
1. Write the `tag_connected_components` function which finds the connected components in a binary image and returns a matrix with the same size in which each connected component is tagged with a different label. The tags should be sequential.
2. Write the `skeletonizeImage` function which skeletonizes objects in a given binary image and returns the new binary image.

**Note** In these images, **1** represents the object, and **0** (black) represents the background.

## Setup Code
Before getting started, we need to run some boilerplate code to set up our environment. You will need to rerun this setup code each time you start the notebook.
"""

import os
import requests
from io import BytesIO
import numpy as np
import matplotlib.pyplot as plt
import PIL

GITHUB_PATH = 'https://raw.githubusercontent.com/dnevo/ImageProcessing/main/images/'

def read_file(file_name:str, file_path:str=GITHUB_PATH) -> np.ndarray:
    '''
    Accept an image file name (defaulty located in GitHub) and return the image 
    in a numpy array.

    Args:
        file_name: the file name
        file_path: the file path.. Default value is Doron's Github repo.

    Returns:
        the image converted into a Numpy array.
    '''
    file_path = os.path.join(file_path, file_name)
    response = requests.get(file_path)
    fp = BytesIO(response.content)

    img_pil = PIL.Image.open(fp)
    return np.array(img_pil, dtype='int16')

def pretty_print(img):
    ''' pretty printing of binary imagees and connected components - by 
    replacing zeros with whitespaces.
    Args:
        img: image in float format (range: 0..1) - the source binary image
        file_path: the file path.. Default value is Doron's Github repo.

    Returns:
        the image converted into a Numpy array.
    '''
    for r in range(img.shape[0]):
        l = [str(img[r,c].astype(np.int16)) if img[r,c]>0 else ' ' for c in range(img.shape[1])]
        print(''.join(map(str, l)))

def plot_images(img1:np.array, img2:np.array):
    fig, axes = plt.subplots(nrows=1, ncols=2, figsize=(14, 6))
    axes[0].imshow(img1,  cmap='gray')
    axes[1].imshow(img2,  cmap='gray')

"""## `tag_connected_components`"""

def tag_connected_components(img: np.array) -> np.array:
    '''
    This function receives a binary image and finds the connected components 
    in it and returns a matrix with the same size in which each connected 
    componnent is tagged with a different label. The tags should be sequential.

    Args:
        img: image in float format (range: 0..1) - the source binary image

    Returns:
        img_new: in float format (range: 0..1) - the image with components 
                 tagging in a 2 dimensional matrice
    '''
    ######################################################################
    # TODO: Implement The tag connected components algorithm.
    ######################################################################
    labels = np.zeros_like(img, dtype=np.uint8)
    component_labels = []
    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]
    for y in range(img.shape[0]):
        for x in range(img.shape[1]):

            if labels[y, x] == 0 and img[y, x] == 1:
                label = len(component_labels) + 1
                component_labels.append(label)
                labels[y, x] = label
                queue = [(y, x)]
                while queue:
                    y0, x0 = queue.pop()
                    for dy, dx in directions:
                        y1, x1 = y0 + dy, x0 + dx
                        if 0 <= y1 < img.shape[0] and 0 <= x1 < img.shape[1] and labels[y1, x1] == 0 and img[y1, x1] == 1:
                            labels[y1, x1] = label
                            queue.append((y1, x1))
    
    img_new = labels.astype(float)

    ######################################################################
    #                            END OF YOUR CODE                        #
    ######################################################################

    return img_new

img = np.array([[0,0,0,0,0,0,0,0,0],
       [0,1,0,0,0,1,0,0,0],
       [0,1,0,1,0,1,0,1,0],
       [0,1,0,1,0,1,0,1,0],
       [0,1,1,1,1,1,0,1,0],
       [0,0,0,0,0,0,0,1,0],
       [0,0,0,0,1,1,1,1,0],
       [0,0,0,0,0,0,0,0,0]])
img_n = tag_connected_components(img)
plot_images(img, img_n)

pretty_print(img_n)

img = read_file('binary1.tiff') / 255
img_n = tag_connected_components(img)
plot_images(img, img_n)

pretty_print(img_n)

img = read_file('binary2.tiff') / 255
img_n = tag_connected_components(img)
plot_images(img, img_n)

pretty_print(img_n)

"""## `skeletonizeImage `"""

def skeletonizeImage (img: np.array) -> np.array:
    '''
    This function receives a binary image and finds the connected components 
    in it and returns a new binary image with skeletonize objects.

    Args:
        img: image in float format (range: 0..1) - the source binary image

    Returns:
        img_new: in float format (range: 0..1) - the image with skeleton 
                    in a 2 dimensional matrice.
    '''
    ######################################################################
    # TODO: Implement The skeletonize algorithm.
    ######################################################################
    # Step 1:
    dists = img.copy()
    dist = 0
    dist_changed = True
    while dist_changed:
      dist = dist + 1
      dist_changed = False
      for r in range(1,img.shape[0]-1):
        for c in range(1,img.shape[1]-1):
          if img[r,c] == 0:
            continue
          min_neighbour_dist = min(dists[r-1, c], dists[r+1, c], dists[r, c-1], dists[r, c+1])
          if min_neighbour_dist >= dist:
            dists[r,c] = dist + 1          
            dist_changed = True


    # Step 2:
    img_new = np.zeros_like(img, dtype=np.uint8)
    for r in range(img.shape[0]):
        for c in range(img.shape[1]):
          if dists[r,c]>=1 and  (dists[r,c] >= dists[r-1,c] and dists[r,c]>= dists[r,c-1] and dists[r,c]>=dists[r+1,c] and dists[r,c]>=dists[r,c+1] ) :
            img_new[r,c]=1
            
    ######################################################################
    #                            END OF YOUR CODE                        #
    ######################################################################
    return img_new

img = np.array([[0,0,0,0,0,0,0,0,0],
                [0,1,1,1,1,1,1,1,0],
                [0,1,1,1,1,1,1,1,0],
                [0,1,1,1,1,1,1,1,0],
                [0,0,0,1,1,1,0,0,0],
                [0,0,0,1,1,1,0,0,0],
                [0,0,0,1,1,1,0,0,0],
                [0,0,0,1,1,1,0,0,0],
                [0,0,0,0,0,0,0,0,0]])
img_new = skeletonizeImage(img)
plot_images(img, img_new)

img = read_file('binary1.tiff') / 255
img_n = skeletonizeImage(img)
plot_images(img, img_n)

img = read_file('binary2.tiff') / 255
img_n = skeletonizeImage(img)
plot_images(img, img_n)

